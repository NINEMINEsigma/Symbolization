# Symbolization
这是一门基于c++编写的语言, 用于实现一些神奇的所见即所得的特性

# 标准

## 定义

只存在两种最基础的语素, 一种是符号, 一种是字符串字面量

- 符号

```text
define, one, open, sadsafas, ;, '', 1, ...
```
符号是不被空格等不可见符号分隔的单个单词

符号为`\S.*`所匹配(虽然不被限制, 但请尽量不要使用双下划线开头的符号)

- 字符串

```text
"define", "one", "open", "asd asda s", ";", "\"", "1", ...
```
字符串的字面量如c的字符串一样, 某些字符需要使用转义字符表达

字符串字面量为`"[^"]*"`所匹配

## 类型

以下列举的类型种类为内置类型, 均不可互相隐式转换

- 数值

数值字面量为`([+-]?)\d+`所匹配的模式, 默认为数值, 分母为1, 符号为正

数值可以表示绝对值最大为2^65-1, 最小精度为1/(2^65-1)的有理数

使用两个数值和分号也可以产生一个数值字面量, 
使用数字字面量的生成模式为`\d+?/\d+?`
```cpp
1/1
+3/2
-5/9
```
注意`([+-]?)\d+?.\d+?`所匹配的不被视作一个可作为数值的符号
```cpp
1.5 != 3/2; //这不是一个数值, 1.5是一个符号
```
并且
```cpp
1.5/2.5 != (3/2)/(5/2); //1.5和2.5都是符号, 不是数值
```
请使用`\d+?\.\d+?f`所匹配的模式来产生一个数值字面量
```cpp
1.5f == 3/2; //1.5f是一个数值
```

- 字符/字符串

字符串字面量为`"[^"]*"`所匹配的模式

字符串的可枚举最小单元为字符, 字符是分母固定为1且符号固定为正的数值类型

在符号没有被[声明](#__build_in_define)前, 非数值字面量的符号内容是符号自身的字符串, 这意味着当text没有被声明时以下两种写法等价
```cpp
string a = text; //使用默认内容的未声明符号
string b = "text"; //使用字符串字面量
```

- 指针

指针字面量为`0x\d+`

指针指向内存中

- 规则

规则是一类特殊的表达式, 在其被定义后将会影响后续的语法或其他内容

关于规则的更多内容在下文被讲述

## 内置符号

大部分内置符号都可以在标准库std中找到对应的无__build_in前缀版本

<a id="__build_in_throw"></a>
<a id="__build_in_error"></a>
- 操作符 `抛出错误` __build_in_throw
- 操作符 `定义错误` __build_in_error

使用方法:
```cpp
throw error(error_id, error_message)
```
使用一个数值类型的id与字符串类型的信息定义错误后抛出

<a id="__build_in_define"></a>
<a id="__build_in_undefine"></a>
- 操作符 `声明` __build_in_define
- 操作符 `取消声明` __build_in_undefine

使用方法:
```cpp
define symbol
undefine symbol
```
声明一个已声明的符号或取消声明一个未声明的符号都会抛出错误

<a id="__build_in_start_region"></a>
<a id="__build_in_end_region"></a>
- 操作符 `开始域` __bulid_in_start_region , std中定义为左大括号{
- 操作符 `结束域` __build_in_end_region , std中定义为右大括号}

开始域与结束域必须配套使用

<a id="__build_in_if"></a>
- __build_in_if

```cpp
__build_in_if(expression)
{

}
else
{

}
```

检查一个符号是否被声明:
```
```